# DEFINITIONS:  -*-sh-*-
# This control file handles a DOBatch calculation with
# spectral_radiance_fieldClearskyPlaneParallel
#
# Author: Oliver Lemke
#

import numpy as np
import arts
from arts.workspace import Workspace, arts_agenda

ws = Workspace(verbosity=0)
ws.execute_controlfile("general/general.arts")
ws.execute_controlfile("general/continua.arts")
ws.execute_controlfile("general/agendas.arts")
ws.execute_controlfile("general/agendasDOIT.arts")
ws.execute_controlfile("general/planet_earth.arts")
# 1.General Settings:---------------------------------------------
# -----------------------------------------------------------------
# Agenda for scalar gas absorption calculation
ws.Copy(ws.abs_xsec_agenda, ws.abs_xsec_agenda__noCIA)
# (standard) emission calculation
ws.Copy(ws.iy_main_agenda, ws.iy_main_agenda__Emission)
# cosmic background radiation
ws.Copy(ws.iy_space_agenda, ws.iy_space_agenda__CosmicBackground)
# standard surface agenda (i.e., make use of surface_rtprop_agenda)
ws.Copy(ws.iy_surface_agenda, ws.iy_surface_agenda__UseSurfaceRtprop)
# sensor-only path
ws.Copy(ws.ppath_agenda, ws.ppath_agenda__FollowSensorLosPath)
# no refraction
ws.Copy(ws.ppath_step_agenda, ws.ppath_step_agenda__GeometricPath)
# Set out put file format
# ------------------------
ws.output_file_formatSetAscii()
# Define f_grid
# --------------
ws.VectorSet(ws.f_grid, array([9.0e10, 1.9e11]))
# Set stokes dim
# --------------
ws.IndexSet(ws.stokes_dim, 1)
# def of atmosphere
# -----------------
ws.IndexSet(ws.atmosphere_dim, 1)
# No jacobian calculations
# -----------------
ws.jacobianOff()
# Modifiy the maximum propagation step, from the default(10.e3)
# to 250 m:---------------------------------------------------
ws.NumericSet(ws.ppath_lmax, 250.0)
# Surface properties
# -------------------
# Set surface reflectivity (=1-emissivity)
# corresponds to emissivity=0.75
ws.VectorSetConstant(ws.surface_scalar_reflectivity, 1, 0.25)
ws.Copy(
    ws.surface_rtprop_agenda,
    ws.surface_rtprop_agenda__Specular_NoPol_ReflFix_SurfTFromt_surface,
)
# 2. Sensor:---------------------------------------------------------
# --------------------------------------------------------------------
# Definition of sensor position and LOS
# ------------------------------------
# Line of sight
ws.MatrixSet(ws.sensor_los, array([[131.0], [179.0]]))
# Sensor position
ws.nrowsGet(ws.nrows, ws.sensor_los)
ws.ncolsGet(ws.ncols, ws.sensor_los)
ws.MatrixSetConstant(ws.sensor_pos, ws.nrows, ws.ncols, 850000.0)
# No sensor characteristics are specified
ws.sensorOff()
# 3. Read chevallier atmospheric profiles for batch calc--------------
# ---------------------------------------------------------------------
ws.ReadXML(ws.batch_atm_fields_compact, "testdata/chevallierl91_all_extract.xml")
# add constant profiles for O2 and N2
ws.batch_atm_fields_compactAddConstant(name="abs_species-O2", value=0.2095)
ws.batch_atm_fields_compactAddConstant(name="abs_species-N2", value=0.7808)
# 4. Absorption-------------------------------------------------
# ---------------------------------------------------------------
ws.abs_speciesSet(species=["H2O-PWR98", "O3", "O2-PWR93", "N2-SelfContStandardType"])
# Creation of abs_lookup table
# -----------------------------
# ATTENTION: The abs_lookup table used with this test control file was
# generated by the following code. It is adapted to the specified abs_species,
# to the specified atmospheric data and frequencies ranging from 80e9 Hz to
# 200e9 Hz. If changes to these inputs are applied the abs_lookup table must
# be recalculated.
# Read HITRAN catalog (needed for O3):
# abs_linesReadFromHitran2004( abs_lines,
#                             "/storage3/data/catalogue/hitran/hitran2004/HITRAN04.par",
#                             80e9,
#                             200e9 )
# abs_lines_per_speciesCreateFromLines
# abs_lookupSetupBatch
# abs_xsec_agenda_checkedCalc
# abs_lookupCalc
# WriteXML("ascii", abs_lookup, "abs_lookupBatch.xml")
# Reading of abs_lookup table
# ----------------------------
ws.ReadXML(ws.abs_lookup, "abs_lookupBatch.xml")
# Check if lookup table is fitting input
ws.abs_lookupAdapt()
# absorption from LUT
ws.Copy(ws.propmat_clearsky_agenda, ws.propmat_clearsky_agenda__LookUpTable)
# 7.AGENDAS--------------------------------------------------------------
# ------------------------------------------------------------------------
# Check the include files to see the setting of Agendas and if needed,
# overwrite them by re-setting the agendas here.------------------------
# Sets the angular grids for radiation calculation
# --------------------------------------------------------------------
# For down- and up-looking geometries.
ws.DOAngularGridsSet(ws.doit_za_grid_size, ws.aa_grid, ws.za_grid, 40, 19, "")
ws.cloudboxOff()
ws.Tensor3Create("trans_field")
# DOBatch Agenda-----------------------------------------------------------
# ------------------------------------------------------------------------
@arts_agenda
def dobatch_calc_agenda(ws):
    # Extract the atmospheric profiles for current atmosphere:
    ws.Extract(ws.atm_fields_compact, ws.batch_atm_fields_compact, ws.ybatch_index)
    # Split up *atm_fields_compact* to
    # generate p_grid, t_field, z_field, massdensity_field, vmr_field
    # Additionally moving TOA down to 10hPa altitude.
    ws.AtmFieldsAndParticleBulkPropFieldFromCompact(p_min=1000.0)
    # Get some surface properties from corresponding atmospheric fields
    ws.Extract(ws.z_surface, ws.z_field, 0)
    ws.Extract(ws.t_surface, ws.t_field, 0)
    # Consistency checks
    ws.atmfields_checkedCalc(bad_partition_functions_ok=1)
    ws.atmgeom_checkedCalc()
    ws.cloudbox_checkedCalc()
    ws.scat_data_checkedCalc()
    ws.sensor_checkedCalc()
    # Here we choose our *y* output unit
    ws.StringSet(ws.iy_unit, "PlanckBT")
    # Calculate radiation field
    ws.spectral_radiance_fieldClearskyPlaneParallel(trans_field=ws.trans_field)
    ws.Touch(ws.radiance_field)
    ws.Touch(ws.irradiance_field)
    ws.Touch(ws.spectral_irradiance_field)


ws.dobatch_calc_agenda = dobatch_calc_agenda

# Set number of batch cases:
ws.nelemGet(ws.ybatch_n, ws.batch_atm_fields_compact)
# IndexSet(ybatch_start, 0)
# Four cases is enough for this example
ws.IndexSet(ws.ybatch_n, 4)
# ===========start batch calc=====================
# Execute the batch calculations:
# This test control file can be run multi-threaded, since it was approved
# that none of the jobs fails.
# If settings are changed, especially if the input atmospheres are altered
# or exchanged, the robust option in *ybatchCalc* should be used.
ws.propmat_clearsky_agenda_checkedCalc()
ws.DOBatchCalc()
# Call *DOBatchCalc* robust:
# Set robust flag to 1. If one individual job fails, ARTS will continue
# with the next batch job.
# DOBatchCalc(robust=1)
# WriteXML( "binary", dobatch_cloudbox_field)
# Verify results
ws.ArrayOfTensor7Create("dobatch_ref")
ws.ReadXML(ws.dobatch_ref, "TestDOBatch.dobatch_doit_i_field.ref.xml")
ws.Compare(
    ws.dobatch_cloudbox_field,
    ws.dobatch_ref,
    1e-07,
    "Total BT should be close to the reference values",
)
# ==================stop==========================
# End of Main
